/* Why is protobufjs giving me JS Number values to represent protobufs
 * enum values when grpc gives me JS String values?
 *
 * https://github.com/dcodeIO/protobuf.js/issues/97
 */
const pbjs = require('protobufjs')
const protobufs = require('../src/protobufs')
const Path = require('path')
const fs = require('fs')
const util = require('util')

const FILE_MAGIC = '/* AUTO-GENERATED BY bs-grpc --- EDIT AT YOUR OWN PERIL */\n';
const preBoilerPlate = `
  exception BsGrpcDecoderError(string);

  /** a type that cannot be instantiated */
  type uninstantiable;
  /** a type to only hold values like Js.Nullable.null and
   * Js.Nullable.undefined */
  type justNull = Js.Nullable.t(uninstantiable);
  type grpcLoadResult;

  [@bs.module "grpc"] external grpcLoadProto : string => grpcLoadResult = "load";

  /* Represents a grpc.Server object */
  type server;
`
const boilerPlate = `
  /* A node.js bufffer TODO see if there is a more standard type somewhere
   * for this. We treat it as opaque, though, so it's probably okay.
   */
  type buffer;

  /* This type is part of the type of grpc.ServerCredentials.createSsl() */
  module ServerKeyAndCert {
    [@bs.deriving abstract]
    type t = {
      [@bs.as "private_key"] privateKey: buffer,
      [@bs.as "cert_chain"] certChain: buffer,
    };
  };

  module Server {
    /* grpc.ServerCredential is a private constructor function. We type it
     * here so that we can access the two public static constructor
     * functions createSsl and createInsecure. The consumer should never
     * have to deal with this type.
     *
     * We treat this type as opaque and bind its function props using
     * bs.send
     *
     * The consumer should not need to deal with this type.
     */
    type serverCredentialsConstructor;
    /* Type for a grpc.Server object */
    /* XXX TODO remove type server; */

    /* credentials is opaque. a credentials value is needed to
     * start a server
     */
    type credentials;
    [@bs.module "grpc"][@bs.val] external grpcCredentials : serverCredentialsConstructor = "ServerCredentials";

    /* These are the public static constructor functions for
     * grpc.ServerCredentials
     */
    [@bs.send]
    external createSsl : (serverCredentialsConstructor, buffer, array(ServerKeyAndCert.t), bool) => credentials = "";
    [@bs.send]
    external createInsecure : serverCredentialsConstructor => credentials = "";
    let createInsecure = () => grpcCredentials |. createInsecure;

    [@bs.module "grpc"][@bs.new]
    external make : unit => server = "Server";

    [@bs.send]
    external serverBind : (server, string, credentials) => unit = "bind";

    [@bs.send]
    external start : server => unit = "start";
  };

  module Client {
    /* "channel credentials" seem to be needed for creating a client
     */
    type channelCredentials;
    type callCredentials;

    /* grpc.credentials contains functions for producing "ChannelCredentials"
     * although I cannot identify a way to simply reach the
     * ChannelCredentials constructor (e.g. grpc.ChannelCredentials)
     *
     * We treat this type as opaque and bind its function props using bs.send
     *
     * The consumer should not need to deal with this type.
     */
    type credentialsObject;

    [@bs.send]
    external createInsecure : credentialsObject => channelCredentials = "";

    [@bs.send]
    external createSsl : (credentialsObject, buffer, buffer, buffer) => channelCredentials = "";

    [@bs.send]
    external combineCredentials : (credentialsObject, channelCredentials, callCredentials) => channelCredentials = "";
  };

  /* we type and obtain a reference to the grpc module so that we can
   * access its properties
   */
  [@bs.deriving abstract]
  type grpcModule = {
    [@bs.as "ServerCredentials"] serverCredentials : Server.serverCredentialsConstructor,
  };
  [@bs.module] external grpc : grpcModule = "";

  /* use this to load a nodejs Buffer object containing a base64-encoded
   * PEM format key/certificate
   */
  [@bs.val] [@bs.module "fs"]
  external loadCert : string => buffer = "readFileSync";

  /* Consumer interfaces */
  let createSslCredentials = (rootCACert:buffer, privateKey:buffer, certChain:buffer) => Server.(
      grpcCredentials |. createSsl(rootCACert, [| ServerKeyAndCert.t( ~privateKey=privateKey, ~certChain=certChain ) |])
  );

/** Convenience function to instantiate and conifgure a GRPC server */
let createServer = (listenAddress, serverCredentials, serviceImplementations) => {
  let server = Server.make();
  Server.serverBind(server, listenAddress, serverCredentials);
  addServices(server, serviceImplementations);
  Server.start(server);
  server;
};

/** Concenience function for simplifying server replies */
let reply = (callback, x) =>
  callback(.
    Js.Nullable.null,
    x,
    Js.Nullable.undefined,
    Js.Nullable.undefined,
  );
`

const dottedModuleName = moduleName =>
  moduleName.split('.').map((s,i) =>
    s[0].toUpperCase() + s.substr(1)
  ).join('.')
const lastDottedPart = moduleName => {
  const a = moduleName.split('.')
  return a[a.length-1]
}
const mapMessageType = messageType => messageType[1].toUpperCase() + messageType.substr(2) + '.t';
const mapEnumType = enumType => enumType[1].toUpperCase() + enumType.substr(2) + '.t';
const joinModuleName = (...args) => args.map(s => s[0]=='.'?s.substr(1):s).join('.')
const resolveRelative = (moduleName, scopeName) => {
  const scopeParts = scopeName.split('.')
  const moduleParts = moduleName.split('.')
  const max = Math.max(scopeParts.length, moduleParts.length)
  for (let i=0; i<max; i++)
    if (scopeParts[i] !== moduleParts[i])
      return moduleParts.slice(i).join('.')
  throw new Error("how do i name myself?")
}
const objMap = (o,f) => { let r = {}; for (let k in o) r[k] = f(o[k], k); return r } // TODO get from a standard lib?
const objJoin = (o,s) => { let r = '', i=0; for (let k in o) r += (i?s+o[k]:o[k]); return r } // TODO get from a standard lib?
const lower1 = s => s[0].toLowerCase()+s.substr(1)
const upper1 = s => s[0].toUpperCase()+s.substr(1)
const firstPart = s => s.split('.')[0]
/* TODO double-check this work
 * TODO what is this called?
 */
const sortish = (a, f) => {
  for (let i=0; i<a.length; i++) {
    for (let j=i+1; j<a.length; j++) {
      if (f(a[i], a[j]) < 0) {
        const tmp = a[i]
        a[i] = a[j]
        a[j] = tmp
      }
    }
  }
}

const mapJustType = (fieldProto, scopeName) => {
  switch (fieldProto.type) {
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_GROUP:
    default:
      return 'unknown_type /*'+type+'*/';
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_ENUM:
      return upper1(resolveRelative(mapEnumType(fieldProto.typeName), scopeName))
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_MESSAGE:
      return upper1(resolveRelative(mapMessageType(fieldProto.typeName), scopeName))
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_BOOL:
      return 'bool'
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_BYTES:
      return 'UNHANDLED_TYPE_BYTES'
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_STRING:
      return 'string'
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_DOUBLE:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_FLOAT:
      return 'float'
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_FIXED32:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_FIXED64:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_INT32:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_INT64:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_SFIXED32:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_SFIXED64:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_SINT32:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_SINT64:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_UINT32:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_UINT64:
      return 'int'
  }
}
const mapType = (fieldProto, scopeName) => {
  const justType = mapJustType(fieldProto, scopeName)
  switch (fieldProto.label) {
    default:
    case protobufs.google.protobuf.FieldDescriptorProto.Label.LABEL_OPTIONAL:
      return ['[@bs.optional]', justType]
    case protobufs.google.protobuf.FieldDescriptorProto.Label.LABEL_REPEATED:
      return ['[@bs.optional]', `array(${justType})`]
    case protobufs.google.protobuf.FieldDescriptorProto.Label.LABEL_REQUIRED:
      return ['/* required */', justType]
  }
}

require('read-all-stream')(process.stdin, {encoding:null}).then(buf => {
  let protoHandleFields = ''
  const reader = pbjs.Reader.create(buf)
  require('fs').writeFileSync('cgr', buf)
  const req = protobufs.google.protobuf.compiler.CodeGeneratorRequest.decode(buf)
  //console.error(util.inspect(req, {depth:999}))

  // XXX deleting noise garbage i don't want to see
  req.protoFile.forEach(protoFile => delete protoFile.sourceCodeInfo)

  /* In order to support custom options in our .proto file, we need to allocate
   * message fields in the protobuf messages that protoc uses to represent our
   * .proto files to our plugin. To do this we need to use the "extend"
   * capability of protobufs. To my intuition, we would apply this step when
   * generating our protoc protobuf compiler, so that the compiler knows about
   * our custom options and how to represent them to our plugin. I
   * haven't been able to figure out a way to do this. Instead, however, we can
   * apparently do the extend at protoc's runtime. Until a better solution is
   * discovered, I am blacklisting the following root packages (__no_emit being
   * my own invention) so that we do not emit code for them.
   */
  const packagePrefixesToIgnore = ['__no_emit', 'google']
  req.protoFile = req.protoFile.filter(protoFile =>
    !packagePrefixesToIgnore.some(prefix =>
      protoFile.package.substr(0, prefix.length) == prefix
    )
  )

  const rootModule = {moduleName:'*root*', modules:{}}

  function handleMessageType(parentModule, messageType) {
    /* Create module for this message type */
    const moduleName = dottedModuleName(joinModuleName(parentModule.moduleName, messageType.name))
    const module =  {
      modules: {},
      moduleName
    }
    parentModule.modules[lastDottedPart(moduleName)] = module
    const message = module.t = {
      fields: messageType.field.map(field => ({
        name: field.name,
        type: field.type,
        typeName: field.typeName,
        oneofIndex: field.hasOwnProperty('oneofIndex') ? field.oneofIndex : -1
      })),
      oneofs: messageType.oneofDecl.map(oneof => ({
        name: oneof.name,
        fields: []
      }))
    }
    messageType.field.forEach((field, iField) => {
      if (field.hasOwnProperty('oneofIndex')) {
        const oneofIndex = field.oneofIndex
        message.oneofs[field.oneofIndex].fields.push(
          message.fields[iField]
        )
      }
    })
    messageType.nestedType.forEach(nestedType => {
      handleMessageType(module, nestedType)
    })
    messageType.enumType.forEach(enumType => {
      handleEnumType(module, enumType)
    })
  }

  function handleEnumType(parentModule, enumType) {
    const moduleName = dottedModuleName(joinModuleName(parentModule.moduleName, enumType.name))
    const module = {
      modules: {},
      moduleName,
      t: { enumValues: enumType.value }
    }
    parentModule.modules[lastDottedPart(moduleName)] = module
  }

  /* For each .proto file... */
  req.protoFile.forEach(protoFile => {
    if (!protoFile.package) {
      console.error('your .proto file must contain a package name')
      process.exit(1)
    }
    /* Create module for this proto file */
    const protoFileModuleName = dottedModuleName(protoFile.package)
    const protoFileModule = {
      modules: {},
      moduleName: protoFileModuleName,
      fileName: protoFile.name,
    }
    rootModule.modules[lastDottedPart(protoFileModuleName)] = protoFileModule
    /* For each message type defined... */
    protoFile.messageType.forEach(messageType => {
      handleMessageType(protoFileModule, messageType)
    })
    protoFile.enumType.forEach(enumType => {
      handleEnumType(protoFileModule, enumType)
    })
    protoFile.service.forEach(service => {
      const moduleName = joinModuleName(protoFileModuleName, service.name)
      const serviceModule = {
        modules: [],
        moduleName,
        /* service modules need this to find their loaded protobuf specs */
        serviceName: service.name,
        rpcs: service.method.map(method => {
          /* TODO support streaming */
          const name = method.name
          const inputType = mapMessageType(method.inputType)
          const outputType = mapMessageType(method.outputType)
          return {
            name,
            inputType,
            outputType
          }
        })
      }
      protoFileModule.modules[lastDottedPart(moduleName)] = serviceModule
    })
  })

  function identifyModules() {
    const foundModules = {}
    recurse(rootModule)
    function recurse(module) {
      foundModules[module.moduleName] = module;
      for (let moduleName in module.modules)
        recurse(module.modules[moduleName])
    }
    return foundModules;
  }
  function identifyServices() {
    const foundServices = {}
    recurse(rootModule)
    function recurse(module) {
      if ('rpcs' in module)
        foundServices[module.moduleName] = {
          fileName: module.fileName,
          module,
        }
      for (let moduleName in module.modules)
        recurse(module.modules[moduleName])
    }
    return foundServices
  }
  function analyzeGraph() {
    const modules = identifyModules();
    for (let moduleName in modules) {
      modules[moduleName].dependencies = {}
      modules[moduleName].visiting = false
    }
    function recurse(module) {
      calcDependencies(module)
      for (let subModuleName in module.modules) {
        recurse(module.modules[subModuleName])
      }
    }
    for (let moduleName in modules)
      recurse(modules[moduleName], 0)
  }
  analyzeGraph()
  /* this is a little sloppy but gets us what we need */
  function calcDependencies(module) {
    module.dependencies = {}
    if ('t' in module) {
      if ('fields' in module.t) {
        module.t.fields.forEach(field => {
          if (field.type == protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_ENUM
            || field.type == protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_MESSAGE) {
            module.dependencies[firstPart(resolveRelative(mapMessageType(field.typeName), module.moduleName))] = true
          }
        })
      }
    }
  }

  const emitModule = module => {
    let code = ''
    /* diagnostic output */
    code += `/* fileName = "${module.fileName}" */\n`
    code += `/* moduleName = "${module.moduleName}" */\n`
    code += `/* dependencies = "${Object.keys(module.dependencies).join('", "')}" */\n`
    /* Invoke grpc-node's load() method to generate and load javascript
     * bindings to our .proto
     */
    if ('fileName' in module) {
      /* TODO will path be correct at runtime?
       * TODO escape path
       */
      code += `
        type grpcProtoHandle;
        [@bs.get] external getProtoHandle : grpcLoadResult => grpcProtoHandle = "chat";
        let myProtoHandle = grpcLoadProto(${JSON.stringify(module.fileName)}) |> getProtoHandle;
      `
    }
    /* sort sub-modules by dependency */
    const subModuleNames = Object.keys(module.modules)
    sortish(subModuleNames, (a,b) => {
      const ma = module.modules[a]
      const mb = module.modules[b]
      return a in mb.dependencies ? 1 : b in ma.dependencies ? -1 : 0
    })
    subModuleNames.sort((a,b) => module.modules[a].score-module.modules[b].score)
    /* emit code for each sub-module in order */
    subModuleNames.forEach(subModuleName => {
      code += `module ${subModuleName} {\n`
      code += emitModule(module.modules[subModuleName])
      code += `};\n`
    })
    /* emit code for any type contained in our module */
    if ('t' in module) {
      if ('fields' in module.t) {
        code += "[@bs.deriving abstract] type t = ";
        if (module.t.fields.length) {
          code += "{\n"
          module.t.fields.forEach(field => {
            const [fieldQualifier, fieldType] = mapType(field, module.moduleName)
            code += `${fieldQualifier} ${field.name} : ${fieldType},\n`
          })
          module.t.oneofs.forEach(oneof => {
            code += `/* oneof */ ${oneof.name}: string,\n`;
          })
          code += "}";
        } else {
          code += "{ /* this type needs at least one field */ [@bs.optional] dontSetMe : string }"
        }
        code += ";\n";
        /* to support protobufs oneof fields, we create a variant type for
         * each oneof.
         */
        module.t.oneofs.forEach(oneof => {
          /* variant type for oneof */
          code += `type ${oneof.name} =\n`
          oneof.fields.forEach(field => {
            code += `| ${upper1(field.name)}(${mapJustType(field, module.moduleName)})\n`
          })
          code += ';\n'
        })
        /* Emit a new constructor function overriding the one emitted by
         * [@bs.deriving abstract] which accepts our oneof variants
         *
         * TODO hide the abstract constructor function "t"
         */
        code += `let make = (\n`
        module.t.fields.forEach(field => {
          if (field.oneofIndex < 0) {
            code += `~${field.name},\n`
          }
        })
        module.t.oneofs.forEach(oneof => {
          code += `~${oneof.name}\n`
        })
        code += ') => t(\n'
        module.t.fields.forEach(field => {
          /* Note the question mark here indicates that we will be passing
           * an option-boxed values explicitly
           */
          code += `~${field.name} =?`
          if (field.oneofIndex >= 0) {
            const oneof = module.t.oneofs[field.oneofIndex]
            code += `(${oneof.name} |> fun\n`
            oneof.fields.forEach(field2 => {
              const varName = field === field2 ? 'x' : '_';
              const valCode = field === field2 ? `Some(x)` : 'None';
              code += `| ${upper1(field2.name)}(${varName}) => ${valCode}\n`
            })
            code += `),`
          } else {
            code += `${field.name},`
          }
          code += `\n`
        })
        module.t.oneofs.forEach(oneof => {
          code += `~${oneof.name} = (${oneof.name} |> fun\n`
          oneof.fields.forEach(field1 => {
            code += `| ${upper1(field1.name)}(_) => ${JSON.stringify(field1.name)}\n`
          })
          code += `),\n`
        })
        code += `);\n`
        /* We'll also override the oneofs' accessor functions (which would
         * only give us a string indicating which of a oneof's fields
         * contains a value) to provide a value of the variant type we
         * created to represent each oneof field
         */
        module.t.oneofs.forEach(oneof => {
          code += `let ${oneof.name} = x => x |> ${oneof.name} |> (fun\n`
          oneof.fields.forEach(field => {
            code += `| ${JSON.stringify(field.name)} => ${upper1(field.name)}(
              x |> ${field.name} |> ( fun
              | Some (x) => x
              | None => raise(BsGrpcDecoderError("expected Some ${field.name}"))
              )
            )\n`
          })
          code += `);\n`
        })
      } else if ('enumValues' in module.t) {
        code += 'type t =\n';
        module.t.enumValues.forEach(enumValue => {
          code += `| ${enumValue.name}\n`
        })
        code += ';\n'
      }
    }
    /* emit code for any RPCs */
    if ('rpcs' in module) {
      module.rpcs.forEach(rpc => {
        const inputType = resolveRelative(rpc.inputType, module.moduleName)
        const outputType = resolveRelative(rpc.outputType, module.moduleName)
        code += `
          module ${upper1(rpc.name)}Rpc {
            [@bs.deriving abstract]
            type call = { request: ${inputType} };
            type t = (
              call,
              (.
                justNull,
                ${outputType},
                justNull,
                justNull
              ) => unit
            ) => unit;
            let getMeta : call => Js.Dict.t(Js.Json.t) = [%bs.raw {|
              call => call.getMap()
            |}];
          };
        `
      })
      code += `
        type grpcServiceClient;
        [@bs.get]
        external myServiceClient
          : grpcProtoHandle => grpcServiceClient
          = ${JSON.stringify(module.serviceName)};
        let myServiceClient = myProtoHandle |> myServiceClient;
        type grpcServiceServer;
        [@bs.get]
        external getServerServiceHandle : grpcServiceClient => grpcServiceServer =
          "service";
        let myServerServiceHandle = myServiceClient |> getServerServiceHandle;
      `
      /* the deriving abstract record type is chosen because it can be fed
       * directly to grpc-node's grpc.Server#addService method
       */
      code += '[@bs.deriving abstract]\ntype t = {\n'
      module.rpcs.forEach(rpc => {
        code += `${lower1(rpc.name)}: ${upper1(rpc.name)}Rpc.t,\n`;
      })
      code += `};
        [@bs.send] external addService : (server, grpcServiceServer, t) => unit = "";
        let addService = (server, t) =>
          addService(server, myServerServiceHandle, t);
      `
    }
    if (module === rootModule) {
      const services = identifyServices()
      let serviceImplementationsFields = ''
      let addServicesCode = ''
      for (let serviceModuleName in services) {
        const serviceModule = services[serviceModuleName].module
        if ('rpcs' in serviceModule) {
          /* populate fields of type servicesImplementation */
          const fieldName = lower1(lastDottedPart(serviceModule.moduleName))
          const fieldType = resolveRelative(serviceModule.moduleName, module.moduleName) + '.t'
          addServicesCode += `switch (serviceImplementations.${fieldName}) {
          | None => ()
          | Some(serviceImplementation) => ${serviceModule.moduleName}.addService(server, serviceImplementation)
          };`
          /* populate fields of protoHandle */
          // TODO remove?
          protoHandleFields += `[@bs.optional] ${fieldName} : ${fieldType}\n`

          serviceImplementationsFields += `${fieldName}: option(${fieldType}),\n`
        }
      }

      code += `
        type serviceImplementations = {
          ${serviceImplementationsFields}
        };

        let addServices = (server:server, serviceImplementations:serviceImplementations) => {
          ${addServicesCode}
          ()
        };
      `
    }
    return code
  }

  const moduleMeat = emitModule(rootModule)

  const emission = FILE_MAGIC
    + preBoilerPlate
    + moduleMeat
    + boilerPlate

  if (process.stdout.isTTY) {
    console.log('stdout is a TTY; printing human-readable data')
    console.log('output module tree:', util.inspect(rootModule, {depth:99}))
    console.log('output source code:')
    console.log(emission)
  } else {
    process.stdout.write(
      protobufs.google.protobuf.compiler.CodeGeneratorResponse.encode({
        file: [{
          name: 'Grpc.re',
          content: emission
        }]
      }).finish()
    )
  }
}).catch(err => {
  console.error(__filename, "error", err)
})
